{
  "hash": "b0940e687608388807b78b266b983dc0",
  "result": {
    "markdown": "---\ntitle: \"Anomaly & Outlier Detection\"\nauthor: \"Sarah Ramboyong\"\ndate: \"2023-12-6\"\nimage: \"anomaly_image.png\"\n---\n\n# Introduction\n\nAnomaly detection is the process of identifying suspicious or unusual occurrences within the dataset. These points are also called outliers and the can effect the performance of machine learning algorithms and skew results. In this blog we will implement one method of anomaly detection, Density-Based Spatial Clustering of Applications with Noise (DBSCAN). We will be using the Iris dataset from sklearn. This dataset contains 150 samples from 3 classes, 50 instances each. It contains the length and width of both sepals and petals.\n\nThis dataset is publically avaliable through the sklearn package with [documentation avaliable].(https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html)\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom sklearn.datasets import load_iris\n\n# Load the iris dataset\niris = load_iris()\n\n# The data, target, and feature names are stored in the data, target, and feature_names attributes, respectively\nX = iris.data\ny = iris.target\nfeature_names = iris.feature_names\n```\n:::\n\n\n# Density-Based Spatial Clustering of Applications with Noise\n\nDBSCAN is an unsupervised clustering machine learning model that defines a neighborhood around each data point, looks at how many points are present within that neighborhood, and then identifies regions were the density of points is higher. Outliers are identified by being points that do not have the minimum number of points in their neighborhood. By being density-based, DBSCAN is able to identify clusters of arbitrary shapes and sizes.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import DBSCAN\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Standardize the features\nscaler = StandardScaler()\nX_std = scaler.fit_transform(X)\n\n# Create a DBSCAN object and fit the data\ndbscan = DBSCAN(eps=0.5, min_samples=5)\nclusters = dbscan.fit_predict(X_std)\n\n# Get the cluster labels\n# -1 = outlier\nlabels = dbscan.labels_\n\n# Get the number of clusters\nn_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n# Identify the outliers\noutliers = np.where(labels == -1)[0]\n\n# Print the number of clusters\nprint(f'Estimated number of clusters: {n_clusters}')\n# Print the number of outliers\nprint(\"Number of outliers:\", len(outliers))\n\n# Plot the data with the outliers highlighted\nplt.scatter(X[:, 0], X[:, 1], c=labels)\nplt.scatter(X[outliers, 0], X[outliers, 1], c=\"red\", marker=\"x\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstimated number of clusters: 2\nNumber of outliers: 34\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-2.png){width=571 height=413}\n:::\n:::\n\n\nFrom this plot we see that our DBSCAN model identified 2 clusters and 34 outliers. We know that this dataset contains 3 different species, so the estimated number of clusters should be 3. We can see that the first two species were, for the most part, correctly identified and the third species was listed entirely as either outliers or as past of the second species. We also see that in the first two clusters, multiple outliers were identified in the bottom right. \n\n# Performance Improvement\n\nWe can improve the performance of DBSCAN by fine-tuning the `eps` and `min_samples` parameters. `eps` is the maximum distance between two samples for them to be considered in the same neighborhood. A small `eps` value means that clusters will be closer together while a larger value means that clusters will be further apart. `min_samples` is the number of points in a neighborhood for a sample to be considered a cluster. \n\nWe will loop over all combinations of `eps` and `min_sample` values and attempt to find a combination that correctly identifies 3 clusters.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# List of possible eps values\neps_values = [0.3, 0.5, 0.7, 0.9]\n\n# List of possible min_samples values\nmin_samples_values = [3, 5, 7, 9]\n\n# Loop over possible eps and min_samples values\nfor eps in eps_values:\n    for min_samples in min_samples_values:\n        dbscan = DBSCAN(eps=eps, min_samples=min_samples)\n        clusters = dbscan.fit_predict(X_std)\n        labels = dbscan.labels_\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n        n_outliers = list(labels).count(-1)\n        print(f'eps={eps}, min_samples={min_samples}, estimated number of clusters={n_clusters}, number of outliers={n_outliers}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neps=0.3, min_samples=3, estimated number of clusters=10, number of outliers=84\neps=0.3, min_samples=5, estimated number of clusters=3, number of outliers=120\neps=0.3, min_samples=7, estimated number of clusters=2, number of outliers=129\neps=0.3, min_samples=9, estimated number of clusters=1, number of outliers=141\neps=0.5, min_samples=3, estimated number of clusters=7, number of outliers=17\neps=0.5, min_samples=5, estimated number of clusters=2, number of outliers=34\neps=0.5, min_samples=7, estimated number of clusters=5, number of outliers=46\neps=0.5, min_samples=9, estimated number of clusters=4, number of outliers=68\neps=0.7, min_samples=3, estimated number of clusters=2, number of outliers=5\neps=0.7, min_samples=5, estimated number of clusters=2, number of outliers=6\neps=0.7, min_samples=7, estimated number of clusters=2, number of outliers=16\neps=0.7, min_samples=9, estimated number of clusters=2, number of outliers=20\neps=0.9, min_samples=3, estimated number of clusters=2, number of outliers=4\neps=0.9, min_samples=5, estimated number of clusters=2, number of outliers=4\neps=0.9, min_samples=7, estimated number of clusters=2, number of outliers=6\neps=0.9, min_samples=9, estimated number of clusters=2, number of outliers=7\n```\n:::\n:::\n\n\nFrom this list we see that the only combination that correctly identified 3 clusters was with `eps`=0.3 and `min_samples`=5. Below is the resulting plot.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Create a DBSCAN object and fit the data\ndbscan = DBSCAN(eps=0.3, min_samples=5)\nclusters = dbscan.fit_predict(X_std)\n\n# Get the cluster labels\n# -1 = outlier\nlabels = dbscan.labels_\n\n# Get the number of clusters\nn_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n# Identify the outliers\noutliers = np.where(labels == -1)[0]\n\n# Print the number of clusters\nprint(f'Estimated number of clusters: {n_clusters}')\n# Print the number of outliers\nprint(\"Number of outliers:\", len(outliers))\n\n# Plot the data with the outliers highlighted\nplt.scatter(X[:, 0], X[:, 1], c=labels)\nplt.scatter(X[outliers, 0], X[outliers, 1], c=\"red\", marker=\"x\")\nplt.title(\"DBSCAN Outlier Detection\")\nplt.suptitle(\"eps=0.3, min_samples=5\", y=0.92)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstimated number of clusters: 3\nNumber of outliers: 120\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-2.png){width=571 height=431}\n:::\n:::\n\n\n Even though the model correctly identified that there are 3 clusters, we can see from the plot that the clusters are not correct. The number of outliers also increased from 34 to 120. \n\n From the list we see that the model with the least number of outliers was with `eps`=0.9 and `min_samples`=3 or `min_samples`=5. Both models tied for only 4 outliers and identified 2 clusters. Below is is both plots.\n\n\n ::: {.cell execution_count=5}\n ``` {.python .cell-code}\n #Create a figure and a set of subplots\n fig,axs = plt.subplots(1, 2, figsize=(10, 5))\n \n #Create a DBSCAN object for min_samples=3 and fit the data\n dbscan1= DBSCAN(eps=0.9, min_samples=3)\n clusters1= dbscan1.fit_predict(X_std)\n \n #Get the cluster labels and identify the outliers\n labels1= dbscan1.labels_\n outliers1= np.where(labels1 == -1)[0]\n \n #Plot the data with the outliers highlighted on the first subplot\n axs[0].scatter(X[:,0], X[:, 1], c=labels1)\n axs[0].scatter(X[outliers1,0], X[outliers1, 1], c=\"red\", marker=\"x\")\n axs[0].set_title(\"DBSCANOutlier Detection (min_samples=3)\")\n \n #Create a DBSCAN object for min_samples=5 and fit the data\n dbscan2= DBSCAN(eps=0.9, min_samples=5)\n clusters2= dbscan2.fit_predict(X_std)\n \n #Get the cluster labels and identify the outliers\n labels2= dbscan2.labels_\n outliers2= np.where(labels2 == -1)[0]\n \n #Plot the data with the outliers highlighted on the second subplot\n axs[1].scatter(X[:,0], X[:, 1], c=labels2)\n axs[1].scatter(X[outliers2,0], X[outliers2, 1], c=\"red\", marker=\"x\")\n axs[1].set_title(\"DBSCANOutlier Detection (min_samples=5)\")\n \n #Display the figure\n plt.tight_layout()\n plt.show()\n ```\n \n ::: {.cell-output .cell-output-display}\n ![](index_files/figure-html/cell-6-output-1.png){width=949 height=470}\n :::\n :::\n \n \nIn both of these plots the model only estimated 2 clusters, however, these clusters look much closer to what we expect than in the previous plots. The number of outliers are also significantly lower than in all previous models. The outliers identified appear to belong to what should be the third cluster, and all other points from that cluster are included in the second cluster.\n\nDBSCAN is not perfect and requires tuning the hyper-parameters for best results, however, is a useful visualization method for identifying anomalies.\n\n## References:\n* https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html\n* https://pieriantraining.com/dbscan-for-outlier-detection-in-python-and-scikit-learn-machine-learning-in-python/\n* https://www.geeksforgeeks.org/detect-and-remove-the-outliers-using-python/\n* https://www.kdnuggets.com/2020/04/dbscan-clustering-algorithm-machine-learning.html#:~:text=low%20point%20density.-,Density%2DBased%20Spatial%20Clustering%20of%20Applications%20with%20Noise%20(DBSCAN),is%20containing%20noise%20and%20outliers.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}